#!/usr/bin/env python

import os
import sys
import hashlib
import logging
import optparse
import requests
import tempfile
import subprocess

from lxml import etree
from lxml.cssselect import CSSSelector

STYLESHEET = """
form,
iframe,
#share,
#footer,
#header,
#sidebar,
#comments,
#topstrip,
#content .dated,
#comments_posting,
div.comment {
  display: none;
}
"""

class WordpressToPDF(object):
    def __init__(self):
        self.session = None

    def main(self):
        parser = optparse.OptionParser(
            usage='%prog [options] <url> <filename.pdf>',
        )

        parser.add_option('--verbosity', dest='verbosity', default=0, type='int',
            help="Verbosity level; 0=minimal output, 1=normal output, "
                "2=verbose output, 3=very verbose output")
        parser.add_option('--cache-dir', dest='cache_dir', default=None,
            help="Download cache dir")
        parser.add_option('--wkhtmltopdf', dest='wkhtmltopdf',
            default='/usr/bin/wkhtmltopdf', help="Location of wkhtmltopdf binary")

        self.options, args = parser.parse_args()

        if len(args) != 2:
            parser.error("must specify an url and an output filename")

        self.options.base_url = args[0]
        self.options.filename = args[1]

        self.setup_logging()

        self.create_pdf()

        return 0

    def create_pdf(self):
        page = self.parse('%s/archives.html' % self.options.base_url)
        links = CSSSelector('div.archive-individual ul.archive-list li a')(page)
        urls = [x.get('href') for x in reversed(links)]

        with tempfile.NamedTemporaryFile() as stylesheet:
            stylesheet.write(STYLESHEET)
            stylesheet.flush()

            args = [
                'wkhtmltopdf',
                '--user-style-sheet', 'file://%s' % stylesheet.name,
                '--allow', self.options.base_url,
                '--disable-javascript',
                '--no-images',
            ]

            if self.options.cache_dir is not None:
                args.extend([
                    '--cache-dir',
                    self.options.cache_dir,
                ])

            args.extend(urls)
            args.append(self.options.filename)

            self.log.info("Executing: %s", ' '.join(args))
            subprocess.check_call(args)

    def parse(self, *args, **kwargs):
        return etree.HTML(self.GET(*args, **kwargs))

    def GET(self, url):
        filename = None
        if self.options.cache_dir is not None:
            filename = os.path.join(
                self.options.cache_dir,
                'cache-%s' % hashlib.sha1(url).hexdigest(),
            )

        if filename and os.path.exists(filename):
            self.log.info("Using cached download for %s from %s", filename, url)
            with open(filename) as f:
                return f.read().decode('utf8')

        if self.session is None:
            self.session = requests.Session()

        response = self.session.get(url)
        response.raise_for_status()

        if filename is not None:
            self.log.info("Caching download for %s at %s", filename, url)
            with open(filename, 'w') as f:
                f.write(response.text.encode('utf8'))

        return response.text

    def setup_logging(self):
        self.log = logging.getLogger()
        self.log.setLevel({
            0: logging.WARNING,
            1: logging.INFO,
            2: logging.DEBUG,
        }[self.options.verbosity])

        handler = logging.StreamHandler(sys.stderr)
        handler.setFormatter(
            logging.Formatter('%(asctime).19s %(levelname).1s %(message)s')
        )
        self.log.addHandler(handler)

if __name__ == '__main__':
    sys.exit(WordpressToPDF().main())
